//..............................................................................
//
//  This file is part of the AXL library.
//
//  AXL is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/axl/license.txt
//
//..............................................................................

#include "pch.h"
#include "axl_io_UsbMonTransfer.h"
#include "axl_io_UsbMonEnumerator.h"

namespace axl {
namespace io {
namespace win {

//..............................................................................

const char*
getUrbFunctionString(uint_t function) {
	static const char* stringTable[0x39] = {
		"URB_FUNCTION_SELECT_CONFIGURATION",             //  URB_FUNCTION_SELECT_CONFIGURATION             0x0000
		"URB_FUNCTION_SELECT_INTERFACE",                 //  URB_FUNCTION_SELECT_INTERFACE                 0x0001
		"URB_FUNCTION_ABORT_PIPE",                       //  URB_FUNCTION_ABORT_PIPE                       0x0002
		"URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL",        //  URB_FUNCTION_TAKE_FRAME_LENGTH_CONTROL        0x0003
		"URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL",     //  URB_FUNCTION_RELEASE_FRAME_LENGTH_CONTROL     0x0004
		"URB_FUNCTION_GET_FRAME_LENGTH",                 //  URB_FUNCTION_GET_FRAME_LENGTH                 0x0005
		"URB_FUNCTION_SET_FRAME_LENGTH",                 //  URB_FUNCTION_SET_FRAME_LENGTH                 0x0006
		"URB_FUNCTION_GET_CURRENT_FRAME_NUMBER",         //  URB_FUNCTION_GET_CURRENT_FRAME_NUMBER         0x0007
		"URB_FUNCTION_CONTROL_TRANSFER",                 //  URB_FUNCTION_CONTROL_TRANSFER                 0x0008
		"URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER",       //  URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER       0x0009
		"URB_FUNCTION_ISOCH_TRANSFER",                   //  URB_FUNCTION_ISOCH_TRANSFER                   0x000A
		"URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE",       //  URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE       0x000B
		"URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE",         //  URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE         0x000C
		"URB_FUNCTION_SET_FEATURE_TO_DEVICE",            //  URB_FUNCTION_SET_FEATURE_TO_DEVICE            0x000D
		"URB_FUNCTION_SET_FEATURE_TO_INTERFACE",         //  URB_FUNCTION_SET_FEATURE_TO_INTERFACE         0x000E
		"URB_FUNCTION_SET_FEATURE_TO_ENDPOINT",          //  URB_FUNCTION_SET_FEATURE_TO_ENDPOINT          0x000F
		"URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE",          //  URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE          0x0010
		"URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE",       //  URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE       0x0011
		"URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT",        //  URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT        0x0012
		"URB_FUNCTION_GET_STATUS_FROM_DEVICE",           //  URB_FUNCTION_GET_STATUS_FROM_DEVICE           0x0013
		"URB_FUNCTION_GET_STATUS_FROM_INTERFACE",        //  URB_FUNCTION_GET_STATUS_FROM_INTERFACE        0x0014
		"URB_FUNCTION_GET_STATUS_FROM_ENDPOINT",         //  URB_FUNCTION_GET_STATUS_FROM_ENDPOINT         0x0015
		"URB_FUNCTION_RESERVED_0X0016",                  //  URB_FUNCTION_RESERVED_0X0016                  0x0016
		"URB_FUNCTION_VENDOR_DEVICE",                    //  URB_FUNCTION_VENDOR_DEVICE                    0x0017
		"URB_FUNCTION_VENDOR_INTERFACE",                 //  URB_FUNCTION_VENDOR_INTERFACE                 0x0018
		"URB_FUNCTION_VENDOR_ENDPOINT",                  //  URB_FUNCTION_VENDOR_ENDPOINT                  0x0019
		"URB_FUNCTION_CLASS_DEVICE",                     //  URB_FUNCTION_CLASS_DEVICE                     0x001A
		"URB_FUNCTION_CLASS_INTERFACE",                  //  URB_FUNCTION_CLASS_INTERFACE                  0x001B
		"URB_FUNCTION_CLASS_ENDPOINT",                   //  URB_FUNCTION_CLASS_ENDPOINT                   0x001C
		"URB_FUNCTION_RESERVE_0X001D",                   //  URB_FUNCTION_RESERVE_0X001D                   0x001D
		"URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL",  //  URB_FUNCTION_SYNC_RESET_PIPE_AND_CLEAR_STALL  0x001E
		"URB_FUNCTION_CLASS_OTHER",                      //  URB_FUNCTION_CLASS_OTHER                      0x001F
		"URB_FUNCTION_VENDOR_OTHER",                     //  URB_FUNCTION_VENDOR_OTHER                     0x0020
		"URB_FUNCTION_GET_STATUS_FROM_OTHER",            //  URB_FUNCTION_GET_STATUS_FROM_OTHER            0x0021
		"URB_FUNCTION_CLEAR_FEATURE_TO_OTHER",           //  URB_FUNCTION_CLEAR_FEATURE_TO_OTHER           0x0022
		"URB_FUNCTION_SET_FEATURE_TO_OTHER",             //  URB_FUNCTION_SET_FEATURE_TO_OTHER             0x0023
		"URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT",     //  URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT     0x0024
		"URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT",       //  URB_FUNCTION_SET_DESCRIPTOR_TO_ENDPOINT       0x0025
		"URB_FUNCTION_GET_CONFIGURATION",                //  URB_FUNCTION_GET_CONFIGURATION                0x0026
		"URB_FUNCTION_GET_INTERFACE",                    //  URB_FUNCTION_GET_INTERFACE                    0x0027
		"URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE",    //  URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE    0x0028
		"URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE",      //  URB_FUNCTION_SET_DESCRIPTOR_TO_INTERFACE      0x0029
		"URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR",        //  URB_FUNCTION_GET_MS_FEATURE_DESCRIPTOR        0x002A
		"URB_FUNCTION_RESERVE_0X002B",                   //  URB_FUNCTION_RESERVE_0X002B                   0x002B
		"URB_FUNCTION_RESERVE_0X002C",                   //  URB_FUNCTION_RESERVE_0X002C                   0x002C
		"URB_FUNCTION_RESERVE_0X002D",                   //  URB_FUNCTION_RESERVE_0X002D                   0x002D
		"URB_FUNCTION_RESERVE_0X002E",                   //  URB_FUNCTION_RESERVE_0X002E                   0x002E
		"URB_FUNCTION_RESERVE_0X002F",                   //  URB_FUNCTION_RESERVE_0X002F                   0x002F
		"URB_FUNCTION_SYNC_RESET_PIPE",                  //  URB_FUNCTION_SYNC_RESET_PIPE                  0x0030
		"URB_FUNCTION_SYNC_CLEAR_STALL",                 //  URB_FUNCTION_SYNC_CLEAR_STALL                 0x0031
		"URB_FUNCTION_CONTROL_TRANSFER_EX",              //  URB_FUNCTION_CONTROL_TRANSFER_EX              0x0032
		"URB_FUNCTION_RESERVE_0X0033",                   //  URB_FUNCTION_RESERVE_0X0033                   0x0033
		"URB_FUNCTION_RESERVE_0X0034",                   //  URB_FUNCTION_RESERVE_0X0034                   0x0034
		"URB_FUNCTION_OPEN_STATIC_STREAMS",              //  URB_FUNCTION_OPEN_STATIC_STREAMS              0x0035
		"URB_FUNCTION_CLOSE_STATIC_STREAMS",             //  URB_FUNCTION_CLOSE_STATIC_STREAMS             0x0036
		"URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_USING_CHAINED_MDL", //  URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER_USING_CHAINED_MDL 0x0037
		"URB_FUNCTION_ISOCH_TRANSFER_USING_CHAINED_MDL", //  URB_FUNCTION_ISOCH_TRANSFER_USING_CHAINED_MDL 0x0038
	};

	return function < countof(stringTable) ?
		stringTable[function] :
		"URB_FUNCTION_UNKNOWN";
}

AXL_SL_BEGIN_SIMPLE_HASH_TABLE(UsbdStatusMap, uint_t, const char*)
	AXL_SL_HASH_TABLE_ENTRY(0x00000000, "USBD_STATUS_SUCCESS")
	AXL_SL_HASH_TABLE_ENTRY(0x00000001, "USBD_STATUS_PORT_OPERATION_PENDING")
	AXL_SL_HASH_TABLE_ENTRY(0x40000000, "USBD_STATUS_PENDING")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000001, "USBD_STATUS_CRC")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000002, "USBD_STATUS_BTSTUFF")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000003, "USBD_STATUS_DATA_TOGGLE_MISMATCH")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000004, "USBD_STATUS_STALL_PID")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000005, "USBD_STATUS_DEV_NOT_RESPONDING")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000006, "USBD_STATUS_PID_CHECK_FAILURE")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000007, "USBD_STATUS_UNEXPECTED_PID")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000008, "USBD_STATUS_DATA_OVERRUN")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000009, "USBD_STATUS_DATA_UNDERRUN")
	AXL_SL_HASH_TABLE_ENTRY(0xC000000A, "USBD_STATUS_RESERVED1")
	AXL_SL_HASH_TABLE_ENTRY(0xC000000B, "USBD_STATUS_RESERVED2")
	AXL_SL_HASH_TABLE_ENTRY(0xC000000C, "USBD_STATUS_BUFFER_OVERRUN")
	AXL_SL_HASH_TABLE_ENTRY(0xC000000D, "USBD_STATUS_BUFFER_UNDERRUN")
	AXL_SL_HASH_TABLE_ENTRY(0xC000000F, "USBD_STATUS_NOT_ACCESSED")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000010, "USBD_STATUS_FIFO")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000011, "USBD_STATUS_XACT_ERROR")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000012, "USBD_STATUS_BABBLE_DETECTED")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000013, "USBD_STATUS_DATA_BUFFER_ERROR")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000014, "USBD_STATUS_NO_PING_RESPONSE")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000015, "USBD_STATUS_INVALID_STREAM_TYPE")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000016, "USBD_STATUS_INVALID_STREAM_ID")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000030, "USBD_STATUS_ENDPOINT_HALTED")
	AXL_SL_HASH_TABLE_ENTRY(0x80000200, "USBD_STATUS_INVALID_URB_FUNCTION")
	AXL_SL_HASH_TABLE_ENTRY(0x80000300, "USBD_STATUS_INVALID_PARAMETER")
	AXL_SL_HASH_TABLE_ENTRY(0x80000400, "USBD_STATUS_ERROR_BUSY")
	AXL_SL_HASH_TABLE_ENTRY(0x80000600, "USBD_STATUS_INVALID_PIPE_HANDLE")
	AXL_SL_HASH_TABLE_ENTRY(0x80000700, "USBD_STATUS_NO_BANDWIDTH")
	AXL_SL_HASH_TABLE_ENTRY(0x80000800, "USBD_STATUS_INTERNAL_HC_ERROR")
	AXL_SL_HASH_TABLE_ENTRY(0x80000900, "USBD_STATUS_ERROR_SHORT_TRANSFER")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000A00, "USBD_STATUS_BAD_START_FRAME")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000B00, "USBD_STATUS_ISOCH_REQUEST_FAILED")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000C00, "USBD_STATUS_FRAME_CONTROL_OWNED")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000D00, "USBD_STATUS_FRAME_CONTROL_NOT_OWNED")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000E00, "USBD_STATUS_NOT_SUPPORTED")
	AXL_SL_HASH_TABLE_ENTRY(0xC0000F00, "USBD_STATUS_INAVLID_CONFIGURATION_DESCRIPTOR")
	AXL_SL_HASH_TABLE_ENTRY(0xC0001000, "USBD_STATUS_INSUFFICIENT_RESOURCES")
	AXL_SL_HASH_TABLE_ENTRY(0xC0002000, "USBD_STATUS_SET_CONFIG_FAILED")
	AXL_SL_HASH_TABLE_ENTRY(0xC0003000, "USBD_STATUS_BUFFER_TOO_SMALL")
	AXL_SL_HASH_TABLE_ENTRY(0xC0004000, "USBD_STATUS_INTERFACE_NOT_FOUND")
	AXL_SL_HASH_TABLE_ENTRY(0xC0005000, "USBD_STATUS_INAVLID_PIPE_FLAGS")
	AXL_SL_HASH_TABLE_ENTRY(0xC0006000, "USBD_STATUS_TIMEOUT")
	AXL_SL_HASH_TABLE_ENTRY(0xC0007000, "USBD_STATUS_DEVICE_GONE")
	AXL_SL_HASH_TABLE_ENTRY(0xC0008000, "USBD_STATUS_STATUS_NOT_MAPPED")
	AXL_SL_HASH_TABLE_ENTRY(0xC0009000, "USBD_STATUS_HUB_INTERNAL_ERROR")
	AXL_SL_HASH_TABLE_ENTRY(0xC0010000, "USBD_STATUS_CANCELED")
	AXL_SL_HASH_TABLE_ENTRY(0xC0020000, "USBD_STATUS_ISO_NOT_ACCESSED_BY_HW")
	AXL_SL_HASH_TABLE_ENTRY(0xC0030000, "USBD_STATUS_ISO_TD_ERROR")
	AXL_SL_HASH_TABLE_ENTRY(0xC0040000, "USBD_STATUS_ISO_NA_LATE_USBPORT")
	AXL_SL_HASH_TABLE_ENTRY(0xC0050000, "USBD_STATUS_ISO_NOT_ACCESSED_LATE")
	AXL_SL_HASH_TABLE_ENTRY(0xC0100000, "USBD_STATUS_BAD_DESCRIPTOR")
	AXL_SL_HASH_TABLE_ENTRY(0xC0100001, "USBD_STATUS_BAD_DESCRIPTOR_BLEN")
	AXL_SL_HASH_TABLE_ENTRY(0xC0100002, "USBD_STATUS_BAD_DESCRIPTOR_TYPE")
	AXL_SL_HASH_TABLE_ENTRY(0xC0100003, "USBD_STATUS_BAD_INTERFACE_DESCRIPTOR")
	AXL_SL_HASH_TABLE_ENTRY(0xC0100004, "USBD_STATUS_BAD_ENDPOINT_DESCRIPTOR")
	AXL_SL_HASH_TABLE_ENTRY(0xC0100005, "USBD_STATUS_BAD_INTERFACE_ASSOC_DESCRIPTOR")
	AXL_SL_HASH_TABLE_ENTRY(0xC0100006, "USBD_STATUS_BAD_CONFIG_DESC_LENGTH")
	AXL_SL_HASH_TABLE_ENTRY(0xC0100007, "USBD_STATUS_BAD_NUMBER_OF_INTERFACES")
	AXL_SL_HASH_TABLE_ENTRY(0xC0100008, "USBD_STATUS_BAD_NUMBER_OF_ENDPOINTS")
	AXL_SL_HASH_TABLE_ENTRY(0xC0100009, "USBD_STATUS_BAD_ENDPOINT_ADDRESS")
AXL_SL_END_SIMPLE_HASH_TABLE()

const char*
getUsbdStatusString(uint_t status) {
	return UsbdStatusMap::findValue(status, "USBD_STATUS_UNKNOWN");
}

} // namespace win

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

sl::StringRef
getUsbMonTransferFlagsString(uint_t flags) {
	return (flags & UsbMonTransferFlag_Completed) ?
	   sl::StringRef("Completed") :
	   sl::StringRef();
}

const char*
getUsbMonControlRecipientString(UsbMonControlRecipient recipient) {
	static const char* stringTable[] = {
		"Device",     // 0
		"Interface",  // 1
		"Endpoint",   // 2
		"Other",      // 3
	};

	return (size_t)recipient < countof(stringTable) ?
		stringTable[recipient] :
		"Unknown";
}

const char*
getUsbMonControlTypeString(UsbMonControlType type) {
	static const char* stringTable[] = {
		"Standard", // 0
		"Class",    // 1
		"Vendor",   // 2
	};

	return (size_t)type < countof(stringTable) ?
		stringTable[type] :
		"Unknown";
}

const char*
getUsbMonControlDirectionString(UsbMonControlDirection direction) {
	static const char* stringTable[] = {
		"Out", // 0
		"In",  // 1
	};

	return (size_t)direction < countof(stringTable) ?
		stringTable[direction] :
		"Unknown";
}

const char*
getUsbMonControlStdRequestString(UsbMonControlStdRequest request) {
	static const char* stringTable[] = {
		"GetStatus",         // 0
		"ClearFeature",      // 1
		"Reserved",          // 2
		"SetFeature",        // 3
		"Reserved2",         // 4
		"SetAddress",        // 5
		"GetDescriptor",     // 6
		"SetDescriptor",     // 7
		"GetConfiguration",  // 8
		"SetConfiguration",  // 9
		"GetInterface",      // 10
		"SetInterface",      // 11
		"SynchFrame",        // 12
	};

	return request < countof(stringTable) ? stringTable[request] : "Unknown";
}

//..............................................................................

} // namespace io
} // namespace axl
