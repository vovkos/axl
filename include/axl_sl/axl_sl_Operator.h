//..............................................................................
//
//  This file is part of the AXL library.
//
//  AXL is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/axl/license.txt
//
//..............................................................................

#pragma once

#define _AXL_SL_OPERATOR_H

#include "axl_sl_ArgType.h"

namespace axl {
namespace sl {

//..............................................................................

// constants

class True {
public:
	bool
	operator () () const {
		return true;
	}
};

class False {
public:
	bool
	operator () () const {
		return false;
	}
};

template <typename T>
class Zero {
public:
	T
	operator () () const {
		return (T)0;
	}
};

template <typename T>
class One {
public:
	T
	operator () () const {
		return (T)1;
	}
};

template <typename T>
class MinusOne {
public:
	T
	operator () () const {
		return (T)-1;
	}
};

// cast operators

template <typename T>
class Void {
public:
	void
	operator () (T x) const {}
};

template <
	typename A,
	typename B
>
class ImplicitCast {
public:
	B
	operator () (A x) const {
		return x;
	}
};

template <
	typename A,
	typename B
>
class ExplicitCast {
public:
	B
	operator () (A x) const {
		return (B)x;
	}
};

template <
	typename A,
	typename B
>
class ImplicitPtrCast {
public:
	B*
	operator () (A* x) const {
		return x;
	}

	const B*
	operator () (const A* x) const {
		return x;
	}
};

template <
	typename A,
	typename B
>
class ExplicitPtrCast {
public:
	B*
	operator () (A* x) const {
		return (B*)x;
	}

	const B*
	operator () (const A* x) const {
		return (const B*) x;
	}
};

//..............................................................................

// sizeof & offsetof operators

template <typename T>
class SizeOf {
public:
	size_t
	operator () () const {
		return sizeof(T);
	}

	size_t
	operator () (const T* x) const {
		return sizeof(T);
	}

	size_t
	operator () (const T& x) const {
		return sizeof(T);
	}
};

template <typename T>
class SizeOfNoReusableTailPadding {
protected:
	struct Calc {
		T m_a;
		char m_b; // this field might be allocated in T's tail-padding
	};

public:
	size_t
	operator () () const {
		return offsetof(Calc, m_b);
	}

	size_t
	operator () (const T* x) const {
		return offsetof(Calc, m_b);
	}

	size_t
	operator () (const T& x) const {
		return offsetof(Calc, m_b);
	}
};

template <
	typename C,
	typename B
>
class OffsetOf {
public:
	size_t
	operator () () const {
		B* p = (C*) 1;
		return (size_t)p - 1;
	}
};

//..............................................................................

// offset (pointer increment) operator

template <
	typename A,
	typename B,
	size_t offset
>
class Offset {
public:
	B*
	operator () (A* p) const {
		return (B*)((uchar_t*)p + offset);
	}
};

//..............................................................................

// NOP (no-operation, identity)

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Nop {
public:
	T
	operator () (Arg a) const {
		return a;
	}
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

// arithmetic operators (sometimes it's necessary to redefine Arg to "const T&")

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Minus {
public:
	T
	operator () (Arg a) const {
		return -a;
	}
};

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Not {
public:
	T
	operator () (Arg a) const {
		return ~a;
	}
};

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Add {
public:
	T
	operator () (
		Arg a,
		Arg b
	) const {
		return a + b;
	}
};

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Sub {
public:
	T
	operator () (
		Arg a,
		Arg b
	) const {
		return a - b;
	}
};

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Mul {
public:
	T
	operator () (
		Arg a,
		Arg b
	) const {
		return a * b;
	}
};

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Div {
public:
	T
	operator () (
		Arg a,
		Arg b
	) const {
		return a / b;
	}
};

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Mod {
public:
	T
	operator () (
		Arg a,
		Arg b
	) const {
		return a % b;
	}
};

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Shl {
public:
	T
	operator () (
		Arg a,
		Arg b
	) const {
		return a << b;
	}
};

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Shr {
public:
	T
	operator () (
		Arg a,
		Arg b
	) const {
		return a >> b;
	}
};

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class And {
public:
	T
	operator () (
		Arg a,
		Arg b
	) const {
		return a & b;
	}
};

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class AndNot {
public:
	T
	operator () (
		Arg a,
		Arg b
	) const {
		return a & ~b;
	}
};

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Xor {
public:
	T
	operator () (
		Arg a,
		Arg b
	) const {
		return a ^ b;
	}
};

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Or {
public:
	T
	operator () (
		Arg a,
		Arg b
	) const {
		return a | b;
	}
};

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Min {
public:
	T
	operator () (
		Arg a,
		Arg b
	) const {
		return a < b ? a : b;
	}
};

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Max {
public:
	T
	operator () (
		Arg a,
		Arg b
	) const {
		return a > b ? a : b;
	}
};

//..............................................................................

// relational operators

enum RelOpKind {
	RelOpKind_Eq = 0,
	RelOpKind_Ne,
	RelOpKind_Lt,
	RelOpKind_Le,
	RelOpKind_Gt,
	RelOpKind_Ge,
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Eq {
public:
	bool
	operator () (
		Arg a,
		Arg b
	) const {
		return a == b;
	}
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class EqBin {
public:
	bool
	operator () (
		Arg a,
		Arg b
	) const {
		return memcmp(&a, &b, sizeof(T)) == 0;
	}
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class EqDuckType {
public:
	bool
	operator () (
		Arg a,
		Arg b
	) const {
		return a.isEqual(b);
	}

	bool
	operator () (
		const T* a,
		const T* b
	) const {
		return a->isEqual(*b);
	}
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

template <typename T>
class EqDuckTypePtr {
public:
	bool
	operator () (
		const T& a,
		const T& b
	) const {
		return a.isEqual(b);
	}

	bool
	operator () (
		const T* a,
		const T* b
	) const {
		return a->isEqual(b);
	}
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Ne {
public:
	bool
	operator () (
		Arg a,
		Arg b
	) const {
		return a != b;
	}
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Lt {
public:
	bool
	operator () (
		Arg a,
		Arg b
	) const {
		return a < b;
	}
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Gt {
public:
	bool
	operator () (
		Arg a,
		Arg b
	) const {
		return a > b;
	}
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Le {
public:
	bool
	operator () (
		Arg a,
		Arg b
	) const {
		return a <= b;
	}
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Ge {
public:
	bool
	operator () (
		Arg a,
		Arg b
	) const {
		return a >= b;
	}
};

//..............................................................................

// assign functors

template <
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class Assign {
public:
	void
	operator () (
		T& a,
		Arg b
	) const {
		a = b;
	}
};

// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

template <
	typename Func,
	typename T,
	typename Arg = typename ArgType<T>::Type
>
class OpAssign {
public:
	void
	operator () (
		T& a,
		Arg b
	) const {
		a = Func() (a, b);
	}
};

//..............................................................................

} // namespace sl
} // namespace axl
